// Generated by CoffeeScript 1.3.3
(function() {
  var __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Milk = (function() {

    Milk.mixin = function() {
      var key, object, objects, target, value, _i, _len;
      target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i];
        for (key in object) {
          value = object[key];
          target[key] = value;
        }
      }
      return target;
    };

    function Milk() {
      var component, components, key, value, _i, _len, _ref;
      components = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.scene = game.scene;
      for (_i = 0, _len = components.length; _i < _len; _i++) {
        component = components[_i];
        if (component != null ? component.isMilkComponent : void 0) {
          this.components || (this.components = []);
          this.components.push(component);
          _ref = component.prototype;
          for (key in _ref) {
            value = _ref[key];
            if (!(this[key] != null)) {
              this[key] = value;
            }
          }
          component.call(this);
        }
      }
    }

    Milk.prototype.componentOperation = function(operationName, args) {
      var component, _i, _len, _ref, _ref1;
      if (this.components) {
        _ref = this.components;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          component = _ref[_i];
          if ((_ref1 = component.prototype[operationName]) != null) {
            _ref1.apply(this, args);
          }
        }
      }
      return null;
    };

    Milk.prototype.stage = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.componentOperation('stage', args);
    };

    Milk.prototype.render = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.componentOperation('render', args);
    };

    Milk.prototype.update = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.componentOperation('update', args);
    };

    Milk.prototype.notReady = function() {
      var className, l, _base;
      this._ready = false;
      if (game.hasLoaded) {
        return;
      }
      className = this.constructor.name;
      Milk.loadingStates || (Milk.loadingStates = {});
      (_base = Milk.loadingStates)[className] || (_base[className] = 0);
      Milk.loadingStates[className] += 1;
      console.log('LOADING', className);
      if (l = $('#chat-log')) {
        return l.append("<li>Loading " + className + "</li>");
      }
    };

    Milk.prototype.ready = function() {
      var className, l;
      this._ready = true;
      if (typeof this.onready === "function") {
        this.onready();
      }
      if (game.hasLoaded) {
        return;
      }
      className = this.constructor.name;
      Milk.loadingStates[className] -= 1;
      console.log('DONE', className);
      if (l = $('#chat-log')) {
        l.append("<li>Done " + className + "</li>");
      }
      if (this.isReady()) {
        return game.ready();
      }
    };

    Milk.prototype.isReady = function() {
      var count, state, _ref;
      if (!game.isReady) {
        return false;
      }
      _ref = Milk.loadingStates;
      for (state in _ref) {
        count = _ref[state];
        if (count > 0) {
          return false;
        }
      }
      return true;
    };

    Milk.prototype.afterReady = function(callback) {
      this.onready = callback;
      if (this._ready) {
        return typeof this.onready === "function" ? this.onready() : void 0;
      }
    };

    Milk.prototype.exportObject = function(object3D) {
      this.object3D = object3D;
      return this.componentOperation('exportObject', [object3D]);
    };

    return Milk;

  })();

  Milk.Component = (function() {

    function Component() {}

    Component.isMilkComponent = true;

    return Component;

  })();

  Milk.Game = (function(_super) {

    __extends(Game, _super);

    function Game() {
      this.render = __bind(this.render, this);
      this.isReady = false;
    }

    Game.prototype.loadLevel = function(levelClass) {
      this.client = new Milk.NetworkClient;
      this.level = new levelClass;
      return this.isReady = true;
    };

    Game.prototype.ready = function() {
      this.hasLoaded = true;
      console.log('DONE LOADING GAME');
      setTimeout((function() {
        return $('#chat-log').html('');
      }), 1500);
      this.stage();
      return this.start();
    };

    Game.prototype.stage = function() {
      return this.level.stage();
    };

    Game.prototype.antialias = true;

    Game.prototype.stats = true;

    Game.prototype.constructRenderer = function() {
      var _this = this;
      if (this.renderer) {
        return;
      }
      if (!this.container) {
        this.container = document.createElement('div');
        document.body.appendChild(this.container);
      }
      this.renderer = new THREE.WebGLRenderer({
        antialias: this.antialias
      });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.container.appendChild(this.renderer.domElement);
      if (this.stats && (typeof Stats !== "undefined" && Stats !== null)) {
        this.stats = new Stats;
        this.stats.domElement.style.position = 'absolute';
        this.stats.domElement.style.top = '0';
        this.container.appendChild(this.stats.domElement);
      }
      return window.addEventListener('resize', function() {
        var camera, height, width;
        width = window.innerWidth;
        height = window.innerHeight;
        camera = _this.level.camera;
        if (camera != null) {
          camera.aspect = width / height;
        }
        _this.renderer.setSize(width, height);
        return camera != null ? camera.updateProjectionMatrix() : void 0;
      }, false);
    };

    Game.prototype.start = function() {
      this.clock = new THREE.Clock;
      this.constructRenderer();
      return requestAnimationFrame(this.render, this.renderer.domElement);
    };

    Game.prototype.render = function(time) {
      var delta, timestep, _ref;
      delta = this.clock.getDelta();
      requestAnimationFrame(this.render, this.renderer.domElement);
      timestep = (time - this.lastFrameTime) * 0.001;
      if ((_ref = this.stats) != null) {
        _ref.update();
      }
      this.level.update();
      return this.level.render(this.renderer);
    };

    return Game;

  })(Milk);

  $(function() {
    window.game = new Milk.Game;
    return game.loadLevel(Milk.MoonLevel);
  });

  /*
  class Scene
  	constructor: ->
  		## PLAYERS
  		@players = {}
  		@vehicles = []
  
  		## MILK
  		geometry = new THREE.PlaneGeometry(256, 256, 1, 1)
  		material = new THREE.MeshPhongMaterial( ambient: 0xffffff, diffuse: 0xffffff, specular: 0xff9900, shininess: 64)
  		@milk = new THREE.Mesh(geometry, material)
  		@milk.doubleSided = true
  		@milk.position.y = 5
  		@add(@milk)
  
  		## TARDIS
  		tardis = new Vehicle.Tardis
  		tardis.position = new THREE.Vector3(-20,10.5,-60)
  		@addVehicle tardis
  
  		## EARTH
  		@earth = new THREE.Mesh(new THREE.SphereGeometry(50,20,20), new THREE.MeshLambertMaterial(map: THREE.ImageUtils.loadTexture("/public/earth.jpg"), color: 0xeeeeee))
  		@earth.position.z= 500
  		@earth.position.y= 79
  		@earth.rotation.y = 2.54
  		@add(@earth)
  
  		# SUN
  		textureFlare0 = THREE.ImageUtils.loadTexture( "/public/lensflare0.png" )
  		textureFlare2 = THREE.ImageUtils.loadTexture( "/public/lensflare2.png" )
  		textureFlare3 = THREE.ImageUtils.loadTexture( "/public/lensflare3.png" )
  
  		flareColor = new THREE.Color( 0xffffff )
  		THREE.ColorUtils.adjustHSV( flareColor, 0, -0.5, 0.5 )
  		@sun = new THREE.LensFlare( textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor )
  		@sun.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending )
  		@sun.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending )
  		@sun.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending )
  
  		@sun.add( textureFlare3, 60, 0.6, THREE.AdditiveBlending )
  		@sun.add( textureFlare3, 70, 0.7, THREE.AdditiveBlending )
  		@sun.add( textureFlare3, 120, 0.9, THREE.AdditiveBlending )
  		@sun.add( textureFlare3, 70, 1.0, THREE.AdditiveBlending )
  		@sun.position.x = 0
  		@sun.position.y = 30
  		@sun.position.z = -500
  		@scene.add(@sun)
  
  		@createRenderer()
  
  	add: (object) ->
  		@scene.add object
  	remove: (object) ->
  		@scene.remove object
  
  	addPlayer: (id, position = new THREE.Vector3(7,12,-70), currentPlayer = false, items) ->
  		p = new Player(id, position, items)
  		@players[id] = p
  		@add(p)
  		if currentPlayer
  			@player = p
  			requestAnimationFrame @render, @renderer.domElement
  
  	addVehicle: (object) ->
  		@scene.add object
  		@vehicles.push object
  
  	enterVehicle: ->
  		for vehicle in @vehicles
  			if vehicle.canEnter()
  				vehicle.player = @player
  				@players[@player.playerId] = vehicle
  				@player = vehicle.enter @player
  				return
  
  	exitVehicle: ->
  		return if @player.playerId
  		window.tardis = @player
  		vehicle = @player
  		vehicle.exit vehicle.player
  
  		@player = vehicle.player
  		@players[@player.playerId] = @player
  
  # Uncomment for .obj loading capabilities
  # THREE.Mesh.loader = new THREE.JSONLoader()
  
  	render: (time) =>
  		return unless @player
  
  		delta = clock.getDelta()
  		requestAnimationFrame @render, @renderer.domElement
  		timestep = (time - @lastFrameTime) * 0.001
  
  		@stats.update()
  		@handler.update(this)
  
  		@player.update(delta)
  
  		mapHeightAtPlayer = @moon.getHeight(@player.position.x, @player.position.z)
  		magicNumber = @player.boundingBox.max.y
  		if mapHeightAtPlayer > @player.position.y - magicNumber
  			@player.position.y = mapHeightAtPlayer + magicNumber
  			@player.jumping = false
  
  		target = @player.position.clone().subSelf(@player.direction().multiplyScalar(-@player.followDistance))
  		@camera.position = @camera.position.addSelf(target.subSelf(@camera.position).multiplyScalar(0.1))
  
  		mapHeightAtCamera = @moon.getHeight(@camera.position.x, @camera.position.z)
  		if mapHeightAtCamera > (@player.position.y - 2)
  			@camera.position.y = mapHeightAtCamera + 2
  			@player.jumping = false
  
  		@camera.lookAt(@player.position)
  		@pointLight.position = @player.position.clone()
  		@pointLight.position.y += 10
  
  		if @player.position.y < (@milk.position.y - 3)
  			@scene.fog.far = 20
  		else
  			@scene.fog.far = 100000
  
  		for vehicle in @vehicles
  			vehicle.update() if vehicle isnt @player
  		for _,player of @players
  			player.afterUpdate()
  
  		@earth.rotation.y += 0.01
  		@earth.rotation.z += 0.005
  		@earth.rotation.x += 0.005
  		@renderer.render @scene, @camera
  
  
  $(document).ready ->
  	window.game = new Scene
  	window.client = new Client game
  	window.chat = new Chat
  	window.inventory = new Inventory
  */


  Milk.Spaceman = (function(_super) {

    __extends(Spaceman, _super);

    function Spaceman() {
      var _this = this;
      Spaceman.__super__.constructor.apply(this, arguments);
      this.notReady();
      this.sprite = new Milk.Sprite("public/robot.png", function() {
        _this.exportObject(_this.sprite.object3D);
        return _this.ready();
      });
    }

    Spaceman.prototype.stage = function() {
      Spaceman.__super__.stage.apply(this, arguments);
      return this.scene.add(this.object3D);
    };

    return Spaceman;

  })(Milk);

  Milk.Movable = (function(_super) {

    __extends(Movable, _super);

    function Movable() {
      this.velocity = 0;
      this.yVelocity = 0;
      this.speed = 0.05;
      this.maxSpeed = 0.2;
      this.angularVelocity = 0;
      this.turnSpeed = 0.01;
      this.maxTurnSpeed = 0.02;
    }

    Movable.prototype.exportObject = function() {
      return this.object3D.useQuaternion = true;
    };

    Movable.prototype.forward = function(direction) {
      this.velocity += this.speed * direction;
      if (this.velocity > this.maxSpeed) {
        return this.velocity = this.maxSpeed;
      } else if (this.velocity < -this.maxSpeed) {
        return this.velocity = -this.maxSpeed;
      }
    };

    Movable.prototype.turn = function(direction) {
      this.angularVelocity += this.turnSpeed * direction;
      if (this.angularVelocity > this.maxTurnSpeed) {
        return this.angularVelocity = this.maxTurnSpeed;
      } else if (this.angularVelocity < -this.maxTurnSpeed) {
        return this.angularVelocity = -this.maxTurnSpeed;
      }
    };

    Movable.prototype.update = function() {
      var magicNumber, mapHeightAtPlayer, rotation;
      rotation = new THREE.Quaternion();
      rotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.angularVelocity);
      this.object3D.quaternion.multiplySelf(rotation);
      this.angularVelocity *= 0.9;
      this.velocity *= 0.8;
      this.object3D.position.subSelf(this.direction().multiplyScalar(this.velocity));
      this.object3D.position.y += this.yVelocity;
      this.yVelocity -= 0.0005;
      mapHeightAtPlayer = game.level.heightAtPosition(this.object3D.position);
      magicNumber = 0.8;
      if (mapHeightAtPlayer > this.object3D.position.y - magicNumber) {
        this.object3D.position.y = mapHeightAtPlayer + magicNumber;
        return this.jumping = false;
      }
    };

    Movable.prototype.updateNetwork = function() {
      return now.sendPlayerUpdate({
        position: this.object3D.position
      });
    };

    Movable.prototype.direction = function() {
      var orient_axis;
      orient_axis = new THREE.Vector3;
      this.object3D.quaternion.multiplyVector3(new THREE.Vector3(0, 0, 1), orient_axis);
      return orient_axis;
    };

    return Movable;

  })(Milk.Component);

  /*
  class Player extends THREE.Object3D
  
  	ITEM_OPTIONS =
  		dino: 'mask'
  		helmet: 'mask'
  		hat: 'hat'
  		milk: 'hand'
  		cookies: 'hand'
  
  	ITEM_OFFSETS =
  		mask:
  			x: 0
  			y: 0.6
  		hand:
  			x: 0.45
  			y: 0
  		hat:
  			x: 0
  			y: 0.9
  
  	followDistance: 8
  
  	constructor: (id, position, startingItems = []) ->
  		super()
  		@playerId = id
  		@position = position
  
  		@velocity = 0
  		@yVelocity = 0
  		@speed = 0.05
  		@maxSpeed = 0.2
  
  		@angularVelocity = 0
  		@turnSpeed = 0.01
  		@maxTurnSpeed = 0.02
  		@useQuaternion = true
  
  		@jumping = false
  		@scaleFactor = 0.0001
  
  		@items = {}
  
  
  		@boundingBox = {max: new THREE.Vector3(1, 0.8, 1)}
  
  		@voicePitch = Math.random()*100
  
  		for item in startingItems
  			@equipItem(item)
  
  	direction: ->
  		c_orient_axis = new THREE.Vector3();
  		@quaternion.multiplyVector3(new THREE.Vector3(0,0,1), c_orient_axis)
  		c_orient_axis
  
  	forward: (direction) ->
  		@velocity += @speed * direction
  		if @velocity > @maxSpeed
  			@velocity = @maxSpeed
  		else if @velocity < -@maxSpeed
  			@velocity = -@maxSpeed
  
  	jump: (direction) ->
  		if !@jumping
  			@yVelocity = @speed
  			@jumping = true
  
  	turn: (direction) ->
  		@angularVelocity += @turnSpeed * direction
  		if @angularVelocity > @maxTurnSpeed
  			@angularVelocity = @maxTurnSpeed
  		else if @angularVelocity < -@maxTurnSpeed
  			@angularVelocity = - @maxTurnSpeed
  
  	equipItem: (item) ->
  		unless @items[item]
  			itemSprite = new Sprite("#{item}.png")
  			slot = ITEM_OPTIONS[item] || "hand"
  			offset = ITEM_OFFSETS[slot]
  			itemSprite.position.set(offset.x, offset.y, 0.001)
  			@add(itemSprite)
  			@items[item] = itemSprite
  
  	unequipItem: (item) ->
  		if @items[item]
  			@remove @items[item]
  			@items[item] = null
  			delete @items[item]
  
  	afterUpdate: ->
  		@messageText?.positionOver this
  
  	displayMessage: (message) ->
  		@clearMessage() if @textMesh
  		speak.play message, pitch: @voicePitch, @clearMessage
  
  		@messageText = new TextObject message
  		game.add @messageText
  
  	clearMessage: =>
  		game.remove @messageText
  		@messageText = null
  */


  /*
  class window.Chat
  	constructor: ->
  		@input = document.getElementById('chat')
  		@input.addEventListener 'keydown', @keyDown, false
  
  	showWindow: ->
  		@input.value = ''
  		@input.style.display = 'block'
  		@input.focus()
  
  	hideWindow: ->
  		@input.blur()
  		@input.style.display = 'none'
  
  	sendMessage: ->
  		message = @input.value
  		client.sendMessage message if message
  
  	receiveMessage: (data) ->
  		callback = -> game.players[data.id].displayMessage data.message
  		callback()
  
  		date = new Date()
  		li = document.createElement 'li'
  		li.innerText = li.textContent = "#{date.getHours()}:#{date.getMinutes()}:#{date.getSeconds()} - #{data.message}"
  		li.addEventListener 'click', callback, false
  
  		document.getElementById('chat-log').appendChild(li)
  		li.scrollIntoView()
  
  	keyDown: (e) =>
  		e.stopPropagation()
  		if e.keyCode is Key.KEYS.enter
  			@sendMessage()
  			@hideWindow()
  		else if e.keyCode is Key.KEYS.escape
  			@hideWindow()
  */


  Milk.Controllable = (function(_super) {

    __extends(Controllable, _super);

    function Controllable() {
      this.followDistance = 8;
    }

    Controllable.prototype.exportObject = function() {
      return Milk.KeyHandler.listen();
    };

    Controllable.prototype.update = function() {
      if (Milk.KeyHandler.isDown('up')) {
        if (typeof this.forward === "function") {
          this.forward(1);
        }
        if (typeof this.queueUpdate === "function") {
          this.queueUpdate();
        }
      }
      if (Milk.KeyHandler.isDown('down')) {
        if (typeof this.forward === "function") {
          this.forward(-1);
        }
        if (typeof this.queueUpdate === "function") {
          this.queueUpdate();
        }
      }
      if (Milk.KeyHandler.isDown('left')) {
        if (typeof this.turn === "function") {
          this.turn(1);
        }
        if (typeof this.queueUpdate === "function") {
          this.queueUpdate();
        }
      }
      if (Milk.KeyHandler.isDown('right')) {
        if (typeof this.turn === "function") {
          this.turn(-1);
        }
        return typeof this.queueUpdate === "function" ? this.queueUpdate() : void 0;
      }
    };

    return Controllable;

  })(Milk.Component);

  Milk.Jumpable = (function(_super) {

    __extends(Jumpable, _super);

    function Jumpable() {
      return Jumpable.__super__.constructor.apply(this, arguments);
    }

    Jumpable.prototype.exportObject = function() {
      return Milk.KeyHandler.listen();
    };

    Jumpable.prototype.update = function() {
      if (Milk.KeyHandler.isDown('space')) {
        this.jump();
        return typeof this.queueUpdate === "function" ? this.queueUpdate() : void 0;
      } else if (this.jumping) {
        return typeof this.queueUpdate === "function" ? this.queueUpdate() : void 0;
      }
    };

    Jumpable.prototype.jump = function() {
      if (!this.jumping) {
        this.yVelocity = this.speed;
        return this.jumping = true;
      }
    };

    return Jumpable;

  })(Milk.Component);

  Milk.HeightMap = (function(_super) {

    __extends(HeightMap, _super);

    function HeightMap(imageURL) {
      var _this = this;
      HeightMap.__super__.constructor.apply(this, arguments);
      this.notReady();
      this.image = new Image();
      this.image.onload = function() {
        return _this.ready();
      };
      if (imageURL) {
        this.image.src = imageURL;
      }
    }

    HeightMap.prototype.stage = function() {
      var cols, geo, height, rows, width;
      width = this.image.width;
      height = this.image.height;
      rows = height - 1;
      cols = width - 1;
      this.metrics = {
        width: width,
        height: height,
        rows: rows,
        cols: cols,
        cellWidth: (rows + 1) / height,
        cellHeight: (cols + 1) / width
      };
      geo = new THREE.PlaneGeometry(width, height, rows, cols);
      geo.dynamic = true;
      this.applyHeightMapToGeometry(geo);
      return geo;
    };

    HeightMap.prototype.applyHeightMapToGeometry = function(geo) {
      var heightData, i, vertex, _i, _len, _ref;
      if (!this.heightData) {
        this.heightDataFromImage();
      }
      heightData = this.heightData;
      _ref = geo.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        vertex = _ref[i];
        vertex.y = heightData[i];
      }
      return geo.computeFaceNormals();
    };

    HeightMap.prototype.heightAtPosition = function(x, z) {
      var cellHeight, cellWidth, col0, col1, gridX, gridZ, h00, h01, h10, h11, height, numCols, numRows, row0, row1, tx, txty, ty;
      if (!this.heightData) {
        this.heightDataFromImage();
      }
      numCols = this.metrics.cols;
      numRows = this.metrics.rows;
      cellWidth = this.metrics.cellWidth;
      cellHeight = this.metrics.cellHeight;
      x += numCols * cellWidth * 0.5;
      z += numRows * cellHeight * 0.5;
      gridX = x / cellWidth;
      gridZ = z / cellHeight;
      col0 = Math.floor(gridX);
      row0 = Math.floor(gridZ);
      col1 = col0 + 1;
      row1 = row0 + 1;
      if (col1 > numCols) {
        col1 = 0;
      }
      if (row1 > numRows) {
        row1 = 0;
      }
      h00 = this.heightData[col0 + row0 * (numCols + 1)];
      h01 = this.heightData[col1 + row0 * (numCols + 1)];
      h11 = this.heightData[col1 + row1 * (numCols + 1)];
      h10 = this.heightData[col0 + row1 * (numCols + 1)];
      tx = gridX - col0;
      ty = gridZ - row0;
      txty = tx * ty;
      height = h00 * (1 - ty - tx + txty) + h01 * (tx - txty) + h11 * txty + h10 * (ty - txty);
      return height;
    };

    HeightMap.prototype.heightDataFromImage = function() {
      var all, canvas, context, height, heightData, i, pixel, pixelIndex, pixels, size, width, _i, _len, _step;
      width = this.image.width;
      height = this.image.height;
      canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      context = canvas.getContext('2d');
      context.drawImage(this.image, 0, 0);
      size = width * height;
      heightData = new Float32Array(size);
      pixels = context.getImageData(0, 0, width, height).data;
      pixelIndex = 0;
      for (i = _i = 0, _len = pixels.length, _step = 4; _i < _len; i = _i += _step) {
        pixel = pixels[i];
        all = pixel + pixels[i + 1] + pixels[i + 2];
        heightData[pixelIndex++] = all / 30;
      }
      return this.heightData = heightData;
    };

    return HeightMap;

  })(Milk);

  /*
  class window.Inventory
    constructor: ->
      @elem = $("#inventory")
      $("body").keydown(@keyDown)
      _this = @
      $('#inventory li').click (e) ->
        item = $(@).find("img").data("item")
        _this.toggleItem(item)
  
    toggle: ->
      @elem.toggle()
  
    toggleItem: (item) ->
      if !game.player.items[item]
        client.sendEquipUpdate(item, true)
      else
        client.sendEquipUpdate(item, false)
  
    keyDown: (e) =>
      if e.keyCode is 73
        @toggle()
  */


  Milk.KeyHandler = (function(_super) {
    var KEY_MAP;

    __extends(KeyHandler, _super);

    function KeyHandler() {
      return KeyHandler.__super__.constructor.apply(this, arguments);
    }

    KEY_MAP = {
      'up': 38,
      'down': 40,
      'left': 37,
      'right': 39,
      'space': 32,
      'enter': 13,
      'escape': 27,
      'e': 69
    };

    KeyHandler.listen = function() {
      var _this = this;
      if (this.downListener) {
        return;
      }
      this.pressed = {};
      this.downListener = window.addEventListener('keydown', function(e) {
        return _this.pressed[e.keyCode] = true;
      });
      return this.upListener = window.addEventListener('keyup', function(e) {
        return _this.pressed[e.keyCode] = false;
      });
    };

    KeyHandler.isDown = function(keyName) {
      return this.pressed[KEY_MAP[keyName]];
    };

    return KeyHandler;

  })(Milk);

  Milk.Level = (function(_super) {

    __extends(Level, _super);

    function Level(options) {
      var aspect, far, fov, near;
      game.scene = new THREE.Scene;
      Level.__super__.constructor.apply(this, arguments);
      if (!(options != null ? options.bootstrap : void 0)) {
        return;
      }
      this.bootstrapped = true;
      fov = 50;
      aspect = window.innerWidth / window.innerHeight;
      near = 1;
      far = 100000;
      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      this.sunLight = new THREE.DirectionalLight;
      this.pointLight = new THREE.PointLight(0x666666);
      this.ambientLight = new THREE.AmbientLight(0x222222);
      this.fog = new THREE.Fog(0x0, 1, 10000);
    }

    Level.prototype.stage = function() {
      if (!this.bootstrapped) {
        return;
      }
      this.scene.add(this.camera);
      this.scene.add(this.sunLight);
      this.scene.add(this.ambientLight);
      this.scene.add(this.pointLight);
      return this.scene.fog = this.fog;
    };

    Level.prototype.render = function(renderer) {
      if (!this.bootstrapped) {
        return;
      }
      return renderer.render(this.scene, this.camera);
    };

    return Level;

  })(Milk);

  /*
  class Moon extends THREE.Object3D
    constructor: ->
      super()
  
      img = new Image()
      img.onload = =>
  
        @height = img.height
        @width = img.width
        @numRows = @height - 1
        @numCols = @width - 1
  
        @cellWidth = (@numRows + 1) / @height
        @cellHeight = (@numCols + 1) / @width
        @geometry = new THREE.PlaneGeometry(@width, @height, @numRows, @numCols)
        @geometry.dynamic = true
  
        @heights = @getHeightData(img)
        for vertex in @geometry.vertices
          vertex.y = @heights[_i]
        @geometry.computeFaceNormals()
  
  
        planeTex = THREE.ImageUtils.loadTexture("public/dirt.jpg")
        planeTex.wrapS = planeTex.wrapT = THREE.RepeatWrapping
        planeTex.repeat.set( 10, 10 )
  
        @material = new THREE.MeshLambertMaterial(map: planeTex, shading: THREE.SmoothShading, specular: 0x0, ambient: 0xeeeeee, diffuse: 0x0, color: 0x555555, shininess: 32)
        @mesh = new THREE.Mesh(@geometry, @material)
        @add(@mesh)
  
      img.src = 'public/map.jpg'
  
    getHeight: (x, z) ->
      return 0 unless @heights
  
      x += @numCols * @cellWidth * 0.5
      z += @numRows * @cellHeight * 0.5
  
      gridX = x / @cellWidth
      gridZ = z / @cellHeight
  
      col0 = Math.floor(gridX)
      row0 = Math.floor(gridZ)
      col1 = col0 + 1
      row1 = row0 + 1
  
  
      # make sure that the cell coordinates don't fall
      # outside the height field.
      if col1 > @numCols
        col1 = 0
      if row1 > @numRows
        row1 = 0
  
      # get the four corner heights of the cell from the height field
      h00 = @heights[col0 + row0 * (@numCols + 1)]
      h01 = @heights[col1 + row0 * (@numCols + 1)]
      h11 = @heights[col1 + row1 * (@numCols + 1)]
      h10 = @heights[col0 + row1 * (@numCols + 1)]
  
      # calculate the position of the camera relative to the cell.
      # note, that 0 <= tx, ty <= 1.
      tx = gridX - col0
      ty = gridZ - row0
  
      # the next step is to perform a bilinear interpolation
      # to compute the height of the terrain directly below
      # the object.
      txty = tx * ty
  
      height = h00 * (1 - ty - tx + txty) + h01 * (tx - txty) + h11 * txty + h10 * (ty - txty)
      height
  
  
    getHeightData: (img) ->
      canvas = document.createElement('canvas')
      canvas.width = img.width
      canvas.height = img.height
      context = canvas.getContext('2d')
  
      size = img.width * img.height
      data = new Float32Array(size)
  
      context.drawImage(img, 0, 0)
  
      imgd = context.getImageData(0, 0, img.width, img.height)
      pix = imgd.data
  
      j = 0
      for pic, i in pix by 4
        all = pic + pix[i + 1] + pix[i + 2]
        data[j++] = all / 30
  
      data
  */


  Milk.MoonLevel = (function(_super) {

    __extends(MoonLevel, _super);

    function MoonLevel() {
      this.receivePlayerUpdate = __bind(this.receivePlayerUpdate, this);

      this.removePlayer = __bind(this.removePlayer, this);

      this.addPlayer = __bind(this.addPlayer, this);
      MoonLevel.__super__.constructor.call(this, {
        bootstrap: true
      });
      this.terrain = new Milk.MoonTerrain;
      this.skybox = new Milk.Skybox("public/skybox");
      this.players = {};
      this.player = new Milk.Spaceman(Milk.Movable, Milk.Controllable, Milk.Jumpable, Milk.Network);
      game.client.observe('addPlayer', this.addPlayer);
      game.client.observe('removePlayer', this.removePlayer);
      game.client.observe('receivePlayerUpdate', this.receivePlayerUpdate);
    }

    MoonLevel.prototype.stage = function() {
      MoonLevel.__super__.stage.apply(this, arguments);
      this.terrain.stage();
      this.skybox.stage();
      return this.player.stage();
    };

    MoonLevel.prototype.update = function() {
      var id, mapHeightAtCamera, player, target, _ref;
      MoonLevel.__super__.update.apply(this, arguments);
      this.player.update();
      _ref = this.players;
      for (id in _ref) {
        player = _ref[id];
        player.update();
      }
      target = this.player.object3D.position.clone().subSelf(this.player.direction().multiplyScalar(-this.player.followDistance));
      this.camera.position = this.camera.position.addSelf(target.subSelf(this.camera.position).multiplyScalar(0.1));
      mapHeightAtCamera = this.terrain.heightAtPosition(this.camera.position);
      if (mapHeightAtCamera > this.player.object3D.position.y - 2) {
        this.camera.position.y = mapHeightAtCamera + 2;
      }
      this.camera.lookAt(this.player.object3D.position);
      this.pointLight.position = this.player.object3D.position.clone();
      return this.pointLight.position.y += 10;
    };

    MoonLevel.prototype.heightAtPosition = function(position) {
      return this.terrain.heightAtPosition(position);
    };

    MoonLevel.prototype.addPlayer = function(data) {
      var player,
        _this = this;
      player = new Milk.Spaceman(Milk.Movable);
      return player.afterReady(function() {
        _this.players['' + data.id] = player;
        player.stage();
        return _this.receivePlayerUpdate(data);
      });
    };

    MoonLevel.prototype.removePlayer = function(data) {
      var player;
      player = this.players['' + data.id];
      this.scene.remove(player.object3D);
      this.players['' + data.id] = null;
      return delete this.players['' + data.id];
    };

    MoonLevel.prototype.receivePlayerUpdate = function(data) {
      var player;
      player = this.players['' + data.id];
      if (data.position) {
        player.yVelocity = 0;
        player.object3D.position.x = data.position.x;
        player.object3D.position.y = data.position.y;
        return player.object3D.position.z = data.position.z;
      }
    };

    return MoonLevel;

  })(Milk.Level);

  Milk.MoonTerrain = (function(_super) {

    __extends(MoonTerrain, _super);

    function MoonTerrain() {
      var _this = this;
      MoonTerrain.__super__.constructor.apply(this, arguments);
      this.heightMap = new Milk.HeightMap("public/map.jpg");
      this.notReady();
      this.texture = THREE.ImageUtils.loadTexture("public/dirt.jpg", null, function() {
        return _this.ready();
      });
      this.texture.wrapS = this.texture.wrapT = THREE.RepeatWrapping;
      this.texture.repeat.set(10, 10);
      this.material = new THREE.MeshLambertMaterial({
        map: this.texture,
        shading: THREE.SmoothShading,
        specular: 0x0,
        ambient: 0xeeeeee,
        diffuse: 0x0,
        color: 0x555555,
        shininess: 32
      });
    }

    MoonTerrain.prototype.stage = function() {
      var geo;
      geo = this.heightMap.stage();
      this.mesh = new THREE.Mesh(geo, this.material);
      return this.scene.add(this.mesh);
    };

    MoonTerrain.prototype.heightAtPosition = function(position) {
      return this.heightMap.heightAtPosition(position.x, position.z);
    };

    return MoonTerrain;

  })(Milk);

  Milk.NetworkClient = (function(_super) {

    __extends(NetworkClient, _super);

    function NetworkClient() {
      var addPlayer,
        _this = this;
      NetworkClient.__super__.constructor.apply(this, arguments);
      this.players = {};
      this.callbacks = {};
      now.welcome = function(data) {
        var id, player, _ref, _results;
        console.log('MY ID IS', _this.id());
        if (data.players) {
          _ref = data.players;
          _results = [];
          for (id in _ref) {
            player = _ref[id];
            _results.push(addPlayer(player));
          }
          return _results;
        }
      };
      now.addPlayer = addPlayer = function(data) {
        if (data.id === _this.id()) {
          return;
        }
        _this.players[data.id] = data;
        return _this.fire('addPlayer', data);
      };
      now.removePlayer = function(data) {
        if (data.id === _this.id()) {
          throw "BAD THINGS";
        }
        _this.players[data.id] = null;
        delete _this.players[data.id];
        return _this.fire('removePlayer', data);
      };
      now.receivePlayerUpdate = function(data) {
        var key, player, value;
        if (data.id === _this.id()) {
          return;
        }
        player = _this.players[data.id];
        for (key in data) {
          value = data[key];
          player[key] = value;
        }
        return _this.fire('receivePlayerUpdate', player);
      };
    }

    NetworkClient.prototype.id = function() {
      return now.core.clientId;
    };

    NetworkClient.prototype.observe = function(eventName, callback) {
      var c, _base;
      c = (_base = this.callbacks)[eventName] || (_base[eventName] = []);
      if (c.indexOf(callback) === -1) {
        return c.push(callback);
      }
    };

    NetworkClient.prototype.fire = function(eventName, data) {
      var c, callback, _i, _len, _results;
      c = this.callbacks[eventName];
      if (c) {
        _results = [];
        for (_i = 0, _len = c.length; _i < _len; _i++) {
          callback = c[_i];
          _results.push(callback(data));
        }
        return _results;
      }
    };

    return NetworkClient;

  })(Milk);

  Milk.Network = (function(_super) {
    var UPDATE_INTERVAL;

    __extends(Network, _super);

    function Network() {
      return Network.__super__.constructor.apply(this, arguments);
    }

    UPDATE_INTERVAL = 30;

    Network.prototype.queueUpdate = function() {
      var _this = this;
      if (this.networkUpdateTimer) {
        return;
      }
      return this.networkUpdateTimer = setTimeout((function() {
        _this.networkUpdateTimer = null;
        return _this.updateNetwork();
      }), UPDATE_INTERVAL);
    };

    return Network;

  })(Milk.Component);

  /*
  class Client
    now = window.now
    constructor: (@game) ->
      now.addPlayers = (players) =>
        for id of players
          player = players[id]
          @game.addPlayer(id, player.position, @id() == id, player.items)
          console.log "CREATING #{id}"
          console.log "I AM #{@id()}"
  
      now.removePlayer = (id) =>
        player = @game.players[id]
        if player
          game.scene.remove(player)
          @game.players[id] = null
          delete @game.players[id]
  
      now.updateInventory = (data) =>
        player = @game.players[data.id]
        if data.equipped
          player.equipItem(data.item)
        else
          player.unequipItem(data.item)
  
      now.updatePlayer = (data) =>
        return if data.id == @id()
        if player = @game.players[data.id]
          player.position.x = data.position.x
          player.position.y = data.position.y
          player.position.z = data.position.z
          player.voicePitch = data.voicePitch
  
      now.receiveMessage = (data) =>
        chat.receiveMessage data
  
      setInterval @sendUpdate, 33
  
    id: ->
      now.core.clientId
  
    sendUpdate: ->
      player = @game.player
      return unless player
      now.sendUpdate
        position: player.position
        voicePitch: player.voicePitch
        items: Object.keys(game.player.items)
  
    sendMessage: (message) ->
      now.sendMessage message
  
    sendEquipUpdate: (item, equipped) ->
      now.sendEquipUpdate item, equipped
  */


  Milk.Skybox = (function(_super) {

    __extends(Skybox, _super);

    function Skybox(filepath) {
      var shader, texture, urls,
        _this = this;
      Skybox.__super__.constructor.apply(this, arguments);
      urls = ["" + filepath + "/posx.png", "" + filepath + "/negx.png", "" + filepath + "/posy.png", "" + filepath + "/negy.png", "" + filepath + "/posz.png", "" + filepath + "/negz.png"];
      this.notReady();
      texture = THREE.ImageUtils.loadTextureCube(urls, null, function() {
        if (texture.image.loadCount === 6) {
          return _this.ready();
        }
      });
      shader = THREE.ShaderUtils.lib.cube;
      shader.uniforms.tCube.texture = texture;
      this.material = new THREE.ShaderMaterial({
        uniforms: shader.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        depthWrite: false
      });
    }

    Skybox.prototype.width = 10000;

    Skybox.prototype.height = 10000;

    Skybox.prototype.depth = 10000;

    Skybox.prototype.stage = function() {
      var geo;
      geo = new THREE.CubeGeometry(this.width, this.height, this.depth, 1, 1, 1, null, true);
      this.mesh = new THREE.Mesh(geo, this.material);
      this.mesh.flipSided = true;
      return this.scene.add(this.mesh);
    };

    return Skybox;

  })(Milk);

  Milk.Sprite = (function(_super) {
    var SCALE_FACTOR;

    __extends(Sprite, _super);

    SCALE_FACTOR = 0.0001;

    function Sprite(filename, callback) {
      var _this = this;
      this.filename = filename;
      Sprite.__super__.constructor.apply(this, arguments);
      this.notReady();
      this.texture = THREE.ImageUtils.loadTexture(this.filename, null, function() {
        _this.mesh = new THREE.Sprite({
          map: _this.texture,
          size: SCALE_FACTOR,
          useScreenCoordinates: false,
          color: 0xffffff
        });
        _this.mesh.scale.x = _this.texture.image.width * SCALE_FACTOR;
        _this.mesh.scale.y = _this.texture.image.height * SCALE_FACTOR;
        _this.exportObject(_this.mesh);
        if (callback != null) {
          callback.call(_this);
        }
        return _this.ready();
      });
    }

    return Sprite;

  })(Milk);

  Milk.Text = (function(_super) {
    var DEFAULT_OPTIONS;

    __extends(Text, _super);

    DEFAULT_OPTIONS = {
      size: 42,
      height: 64,
      curveSegments: 4,
      font: "helvetiker",
      weight: "normal",
      style: "normal",
      bevelEnabled: true,
      bevelThickness: 1,
      bevelSize: 1,
      bend: true,
      material: 0,
      extrudeMaterial: 1
    };

    function Text(message, options) {
      if (message == null) {
        message = '';
      }
      if (options == null) {
        options = {};
      }
      this.message = message;
      this.options = Milk.mixin({}, DEFAULT_OPTIONS, options);
      this.faceMaterial = new THREE.MeshFaceMaterial;
      this.frontMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        shading: THREE.FlatShading
      });
      this.sideMaterial = new THREE.MeshBasicMaterial({
        color: 0xbbbbbb,
        shading: THREE.SmoothShading
      });
      this.scale = 0.015;
    }

    Text.prototype.render = function() {
      var geo, mesh;
      geo = new THREE.TextGeometry(this.message, this.options);
      geo.materials = [this.frontMaterial, this.sideMaterial];
      geo.computeBoundingBox();
      geo.computeVertexNormals();
      this.midX = geo.boundingBox.max.x * this.scale / 2;
      mesh = new THREE.Mesh(geo, this.faceMaterial);
      mesh.scale = new THREE.Vector3(this.scale, this.scale, this.scale);
      return this.exportObject(mesh);
    };

    Text.prototype.update = function() {};

    Text.prototype.positionOver = function(object) {
      this.position.x = object.position.x;
      this.position.y = object.position.y + object.boundingBox.max.y + 0.5;
      this.position.z = object.position.z;
      this.lookAt(game.camera.position);
      return this.translateX(-this.width);
    };

    return Text;

  })(Milk);

  Milk.OverheadText = (function() {

    function OverheadText() {}

    return OverheadText;

  })();

  /*
  
  class window.Vehicle extends Player
  	enterTextShown: false
  	hasEntered: false
  	followDistance: 12
  
  	canEnter: ->
  		(!@hasEntered) and game.player.position.distanceToSquared(@position) < 75
  
  	enter: (player) ->
  		if not @backgroundAudio
  			@backgroundAudio = audio = document.createElement 'audio'
  			source = document.createElement 'source'
  			source.src = '/public/doctorwho.mp3'
  			audio.appendChild source
  			source = document.createElement 'source'
  			source.src = '/public/doctorwho.ogg'
  			audio.appendChild source
  			audio.autoplay = true
  			document.body.appendChild audio
  		else
  			@backgroundAudio.play()
  
  		game.remove @enterText
  		@hasEntered = true
  
  		player.parent.remove player
  		player.position.x = player.position.y = player.position.z = 0
  		@add player
  
  		return this
  
  	exit: (player) ->
  		@hasEntered = false
  		@backgroundAudio.pause()
  
  		@remove player
  		player.position.x = @position.x + 5
  		player.position.y = @position.y
  		player.position.z = @position.z + 5
  		game.add player
  
  		console.log @position.y
  
  	jump: ->
  		if not @wooshAudio
  			@wooshAudio = audio = document.createElement 'audio'
  			source = document.createElement 'source'
  			source.src = '/public/tardis.mp3'
  			audio.appendChild source
  			document.body.appendChild audio
  
  		super
  
  	update: (delta) ->
  		if @hasEntered
  			@wooshAudio?[if @jumping then 'play' else 'pause']()
  			super
  
  		else if @canEnter()
  			if @enterTextShown
  				@enterText.positionOver this
  			else
  				@enterTextShown = true
  				game.add @enterText
  		else
  			if @enterTextShown
  				@enterTextShown = false
  				game.remove @enterText
  
  class Vehicle.Tardis extends Vehicle
  	constructor: ->
  		super
  
  		geometry = new THREE.CubeGeometry(3, 5, 3)
  		material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("/public/tardisFront.jpg")})
  		mesh = new THREE.Mesh(geometry, material)
  		@add mesh
  
  		geometry.computeBoundingBox()
  		@boundingBox = geometry.boundingBox
  
  		@enterText = new TextObject 'press e to enter the tardis'
  */


}).call(this);
