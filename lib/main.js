// Generated by CoffeeScript 1.3.3
(function() {
  var __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Milk = (function() {

    Milk.mixin = function() {
      var key, object, objects, target, value, _i, _len;
      target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i];
        for (key in object) {
          value = object[key];
          target[key] = value;
        }
      }
      return target;
    };

    function Milk() {
      this.scene = game.scene;
    }

    Milk.prototype.notReady = function() {
      var className, _base;
      className = this.constructor.name;
      Milk.loadingStates || (Milk.loadingStates = {});
      (_base = Milk.loadingStates)[className] || (_base[className] = 0);
      Milk.loadingStates[className] += 1;
      return console.log('LOADING', className);
    };

    Milk.prototype.ready = function() {
      var className;
      className = this.constructor.name;
      Milk.loadingStates[className] -= 1;
      console.log('DONE', className);
      if (this.isReady()) {
        return game.ready();
      }
    };

    Milk.prototype.isReady = function() {
      var count, state, _ref;
      if (!game.isReady) {
        return false;
      }
      _ref = Milk.loadingStates;
      for (state in _ref) {
        count = _ref[state];
        if (count > 0) {
          return false;
        }
      }
      return true;
    };

    return Milk;

  })();

  Milk.Game = (function(_super) {

    __extends(Game, _super);

    function Game() {
      this.render = __bind(this.render, this);
      this.isReady = false;
    }

    Game.prototype.loadLevel = function(levelClass) {
      this.level = new levelClass;
      return this.isReady = true;
    };

    Game.prototype.ready = function() {
      console.log('DONE LOADING GAME');
      this.stage();
      return this.start();
    };

    Game.prototype.stage = function() {
      return this.level.stage();
    };

    Game.prototype.antialias = true;

    Game.prototype.stats = true;

    Game.prototype.constructRenderer = function() {
      var _this = this;
      if (this.renderer) {
        return;
      }
      if (!this.container) {
        this.container = document.createElement('div');
        document.body.appendChild(this.container);
      }
      this.renderer = new THREE.WebGLRenderer({
        antialias: this.antialias
      });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.container.appendChild(this.renderer.domElement);
      if (this.stats && (typeof Stats !== "undefined" && Stats !== null)) {
        this.stats = new Stats;
        this.stats.domElement.style.position = 'absolute';
        this.stats.domElement.style.top = '0';
        this.container.appendChild(this.stats.domElement);
      }
      return window.addEventListener('resize', function() {
        var camera, height, width;
        width = window.innerWidth;
        height = window.innerHeight;
        camera = _this.level.camera;
        if (camera != null) {
          camera.aspect = width / height;
        }
        _this.renderer.setSize(width, height);
        return camera != null ? camera.updateProjectionMatrix() : void 0;
      }, false);
    };

    Game.prototype.start = function() {
      this.clock = new THREE.Clock;
      this.constructRenderer();
      return requestAnimationFrame(this.render, this.renderer.domElement);
    };

    Game.prototype.render = function(time) {
      var delta, timestep, _ref;
      delta = this.clock.getDelta();
      requestAnimationFrame(this.render, this.renderer.domElement);
      timestep = (time - this.lastFrameTime) * 0.001;
      if ((_ref = this.stats) != null) {
        _ref.update();
      }
      this.level.update();
      return this.level.render(this.renderer);
    };

    return Game;

  })(Milk);

  $(function() {
    window.game = new Milk.Game;
    return game.loadLevel(Milk.MoonLevel);
  });

  /*
  class Scene
  	constructor: ->
  		## PLAYERS
  		@players = {}
  		@vehicles = []
  
  		## MILK
  		geometry = new THREE.PlaneGeometry(256, 256, 1, 1)
  		material = new THREE.MeshPhongMaterial( ambient: 0xffffff, diffuse: 0xffffff, specular: 0xff9900, shininess: 64)
  		@milk = new THREE.Mesh(geometry, material)
  		@milk.doubleSided = true
  		@milk.position.y = 5
  		@add(@milk)
  
  		## TARDIS
  		tardis = new Vehicle.Tardis
  		tardis.position = new THREE.Vector3(-20,10.5,-60)
  		@addVehicle tardis
  
  		## EARTH
  		@earth = new THREE.Mesh(new THREE.SphereGeometry(50,20,20), new THREE.MeshLambertMaterial(map: THREE.ImageUtils.loadTexture("/public/earth.jpg"), color: 0xeeeeee))
  		@earth.position.z= 500
  		@earth.position.y= 79
  		@earth.rotation.y = 2.54
  		@add(@earth)
  
  		# SUN
  		textureFlare0 = THREE.ImageUtils.loadTexture( "/public/lensflare0.png" )
  		textureFlare2 = THREE.ImageUtils.loadTexture( "/public/lensflare2.png" )
  		textureFlare3 = THREE.ImageUtils.loadTexture( "/public/lensflare3.png" )
  
  		flareColor = new THREE.Color( 0xffffff )
  		THREE.ColorUtils.adjustHSV( flareColor, 0, -0.5, 0.5 )
  		@sun = new THREE.LensFlare( textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor )
  		@sun.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending )
  		@sun.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending )
  		@sun.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending )
  
  		@sun.add( textureFlare3, 60, 0.6, THREE.AdditiveBlending )
  		@sun.add( textureFlare3, 70, 0.7, THREE.AdditiveBlending )
  		@sun.add( textureFlare3, 120, 0.9, THREE.AdditiveBlending )
  		@sun.add( textureFlare3, 70, 1.0, THREE.AdditiveBlending )
  		@sun.position.x = 0
  		@sun.position.y = 30
  		@sun.position.z = -500
  		@scene.add(@sun)
  
  		@createRenderer()
  
  	add: (object) ->
  		@scene.add object
  	remove: (object) ->
  		@scene.remove object
  
  	addPlayer: (id, position = new THREE.Vector3(7,12,-70), currentPlayer = false, items) ->
  		p = new Player(id, position, items)
  		@players[id] = p
  		@add(p)
  		if currentPlayer
  			@player = p
  			requestAnimationFrame @render, @renderer.domElement
  
  	addVehicle: (object) ->
  		@scene.add object
  		@vehicles.push object
  
  	enterVehicle: ->
  		for vehicle in @vehicles
  			if vehicle.canEnter()
  				vehicle.player = @player
  				@players[@player.playerId] = vehicle
  				@player = vehicle.enter @player
  				return
  
  	exitVehicle: ->
  		return if @player.playerId
  		window.tardis = @player
  		vehicle = @player
  		vehicle.exit vehicle.player
  
  		@player = vehicle.player
  		@players[@player.playerId] = @player
  
  # Uncomment for .obj loading capabilities
  # THREE.Mesh.loader = new THREE.JSONLoader()
  
  	render: (time) =>
  		return unless @player
  
  		delta = clock.getDelta()
  		requestAnimationFrame @render, @renderer.domElement
  		timestep = (time - @lastFrameTime) * 0.001
  
  		@stats.update()
  		@handler.update(this)
  
  		@player.update(delta)
  
  		mapHeightAtPlayer = @moon.getHeight(@player.position.x, @player.position.z)
  		magicNumber = @player.boundingBox.max.y
  		if mapHeightAtPlayer > @player.position.y - magicNumber
  			@player.position.y = mapHeightAtPlayer + magicNumber
  			@player.jumping = false
  
  		target = @player.position.clone().subSelf(@player.direction().multiplyScalar(-@player.followDistance))
  		@camera.position = @camera.position.addSelf(target.subSelf(@camera.position).multiplyScalar(0.1))
  
  		mapHeightAtCamera = @moon.getHeight(@camera.position.x, @camera.position.z)
  		if mapHeightAtCamera > (@player.position.y - 2)
  			@camera.position.y = mapHeightAtCamera + 2
  			@player.jumping = false
  
  		@camera.lookAt(@player.position)
  		@pointLight.position = @player.position.clone()
  		@pointLight.position.y += 10
  
  		if @player.position.y < (@milk.position.y - 3)
  			@scene.fog.far = 20
  		else
  			@scene.fog.far = 100000
  
  		for vehicle in @vehicles
  			vehicle.update() if vehicle isnt @player
  		for _,player of @players
  			player.afterUpdate()
  
  		@earth.rotation.y += 0.01
  		@earth.rotation.z += 0.005
  		@earth.rotation.x += 0.005
  		@renderer.render @scene, @camera
  
  
  $(document).ready ->
  	window.game = new Scene
  	window.client = new Client game
  	window.chat = new Chat
  	window.inventory = new Inventory
  */


  /*
  class window.Chat
  	constructor: ->
  		@input = document.getElementById('chat')
  		@input.addEventListener 'keydown', @keyDown, false
  
  	showWindow: ->
  		@input.value = ''
  		@input.style.display = 'block'
  		@input.focus()
  
  	hideWindow: ->
  		@input.blur()
  		@input.style.display = 'none'
  
  	sendMessage: ->
  		message = @input.value
  		client.sendMessage message if message
  
  	receiveMessage: (data) ->
  		callback = -> game.players[data.id].displayMessage data.message
  		callback()
  
  		date = new Date()
  		li = document.createElement 'li'
  		li.innerText = li.textContent = "#{date.getHours()}:#{date.getMinutes()}:#{date.getSeconds()} - #{data.message}"
  		li.addEventListener 'click', callback, false
  
  		document.getElementById('chat-log').appendChild(li)
  		li.scrollIntoView()
  
  	keyDown: (e) =>
  		e.stopPropagation()
  		if e.keyCode is Key.KEYS.enter
  			@sendMessage()
  			@hideWindow()
  		else if e.keyCode is Key.KEYS.escape
  			@hideWindow()
  */


  /*
  class Client
    now = window.now
    constructor: (@game) ->
      now.addPlayers = (players) =>
        for id of players
          player = players[id]
          @game.addPlayer(id, player.position, @id() == id, player.items)
          console.log "CREATING #{id}"
          console.log "I AM #{@id()}"
  
      now.removePlayer = (id) =>
        player = @game.players[id]
        if player
          game.scene.remove(player)
          @game.players[id] = null
          delete @game.players[id]
  
      now.updateInventory = (data) =>
        player = @game.players[data.id]
        if data.equipped
          player.equipItem(data.item)
        else
          player.unequipItem(data.item)
  
      now.updatePlayer = (data) =>
        return if data.id == @id()
        if player = @game.players[data.id]
          player.position.x = data.position.x
          player.position.y = data.position.y
          player.position.z = data.position.z
          player.voicePitch = data.voicePitch
  
      now.receiveMessage = (data) =>
        chat.receiveMessage data
  
      setInterval @sendUpdate, 33
  
    id: ->
      now.core.clientId
  
    sendUpdate: ->
      player = @game.player
      return unless player
      now.sendUpdate
        position: player.position
        voicePitch: player.voicePitch
        items: Object.keys(game.player.items)
  
    sendMessage: (message) ->
      now.sendMessage message
  
    sendEquipUpdate: (item, equipped) ->
      now.sendEquipUpdate item, equipped
  */


  Milk.HeightMap = (function(_super) {

    __extends(HeightMap, _super);

    function HeightMap(imageURL) {
      var _this = this;
      HeightMap.__super__.constructor.apply(this, arguments);
      this.notReady();
      this.image = new Image();
      this.image.onload = function() {
        return _this.ready();
      };
      if (imageURL) {
        this.image.src = imageURL;
      }
    }

    HeightMap.prototype.stage = function() {
      var cols, geo, height, rows, width;
      width = this.image.width;
      height = this.image.height;
      rows = width - 1;
      cols = height - 1;
      this.metrics = {
        width: width,
        height: height,
        rows: rows,
        cols: height,
        cellWidth: (rows + 1) / height,
        cellHeight: (cols + 1) / width
      };
      geo = new THREE.PlaneGeometry(width, height, rows, cols);
      geo.dynamic = true;
      return this.applyHeightMapToGeometry(geo);
    };

    HeightMap.prototype.applyHeightMapToGeometry = function(geo) {
      var heightData, i, vertex, _i, _len, _ref;
      if (!this.heightData) {
        this.heightData = this.heightDataFromImage();
      }
      heightData = this.heightData;
      _ref = geo.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        vertex = _ref[i];
        vertex.y = heightData[i];
      }
      return geo;
    };

    HeightMap.prototype.heightAtPosition = function(position) {
      var col0, col1, gridX, gridZ, h00, h01, h10, h11, height, row0, row1, tx, txty, ty, x, z;
      if (!this.heightData) {
        this.heightData = this.heightDataFromImage();
      }
      x = position.x + this.metrics.cols * this.metrics.cellWidth * 0.5;
      z = position.z + this.metrics.rows * this.metrics.cellHeight * 0.5;
      gridX = x / this.metrics.cellWidth;
      gridZ = z / this.metrics.cellHeight;
      col0 = Math.floor(gridX);
      row0 = Math.floor(gridZ);
      col1 = col0 + 1;
      row1 = row0 + 1;
      if (col1 > this.metrics.cols) {
        col1 = 0;
      }
      if (row1 > this.metrics.rows) {
        row1 = 0;
      }
      h00 = this.heightData[col0 + row0 * (this.metrics.cols + 1)];
      h01 = this.heightData[col1 + row0 * (this.metrics.cols + 1)];
      h11 = this.heightData[col1 + row1 * (this.metrics.cols + 1)];
      h10 = this.heightData[col0 + row1 * (this.metrics.cols + 1)];
      tx = gridX - col0;
      ty = gridZ - row0;
      txty = tx * ty;
      height = h00 * (1 - ty - tx + txty) + h01 * (tx - txty) + h11 * txty + h10 * (ty - txty);
      return height;
    };

    HeightMap.prototype.heightDataFromImage = function() {
      var all, canvas, context, height, heightData, i, pixel, pixelIndex, pixels, size, width, _i, _len, _step;
      width = this.image.width;
      height = this.image.height;
      canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      context = canvas.getContext('2d');
      context.drawImage(this.image, 0, 0);
      size = width * height;
      heightData = new Float32Array(size);
      pixels = context.getImageData(0, 0, width, height).data;
      pixelIndex = 0;
      for (i = _i = 0, _len = pixels.length, _step = 4; _i < _len; i = _i += _step) {
        pixel = pixels[i];
        all = pixel + pixels[i + 1] + pixels[i + 2];
        heightData[pixelIndex++] = all / 30;
      }
      return heightData;
    };

    return HeightMap;

  })(Milk);

  /*
  class window.Inventory
    constructor: ->
      @elem = $("#inventory")
      $("body").keydown(@keyDown)
      _this = @
      $('#inventory li').click (e) ->
        item = $(@).find("img").data("item")
        _this.toggleItem(item)
  
    toggle: ->
      @elem.toggle()
  
    toggleItem: (item) ->
      if !game.player.items[item]
        client.sendEquipUpdate(item, true)
      else
        client.sendEquipUpdate(item, false)
  
    keyDown: (e) =>
      if e.keyCode is 73
        @toggle()
  */


  Milk.KeyHandler = (function(_super) {

    __extends(KeyHandler, _super);

    function KeyHandler() {
      return KeyHandler.__super__.constructor.apply(this, arguments);
    }

    return KeyHandler;

  })(Milk);

  Milk.Level = (function(_super) {

    __extends(Level, _super);

    function Level(options) {
      var aspect, far, fov, near;
      game.scene = new THREE.Scene;
      Level.__super__.constructor.apply(this, arguments);
      if (!(options != null ? options.bootstrap : void 0)) {
        return;
      }
      this.bootstrapped = true;
      fov = 50;
      aspect = window.innerWidth / window.innerHeight;
      near = 1;
      far = 100000;
      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      this.sunLight = new THREE.DirectionalLight;
      this.pointLight = new THREE.PointLight(0x666666);
      this.ambientLight = new THREE.AmbientLight(0x222222);
      this.fog = new THREE.Fog(0x0, 1, 10000);
    }

    Level.prototype.stage = function() {
      if (!this.bootstrapped) {
        return;
      }
      this.scene.add(this.camera);
      this.scene.add(this.sunLight);
      this.scene.add(this.ambientLight);
      this.scene.add(this.pointLight);
      return this.scene.fog = this.fog;
    };

    Level.prototype.render = function(renderer) {
      if (!this.bootstrapped) {
        return;
      }
      return renderer.render(this.scene, this.camera);
    };

    return Level;

  })(Milk);

  /*
  class Moon extends THREE.Object3D
    constructor: ->
      super()
  
      img = new Image()
      img.onload = =>
  
        @height = img.height
        @width = img.width
        @numRows = @height - 1
        @numCols = @width - 1
  
        @cellWidth = (@numRows + 1) / @height
        @cellHeight = (@numCols + 1) / @width
        @geometry = new THREE.PlaneGeometry(@width, @height, @numRows, @numCols)
        @geometry.dynamic = true
  
        @heights = @getHeightData(img)
        for vertex in @geometry.vertices
          vertex.y = @heights[_i]
        @geometry.computeFaceNormals()
  
  
        planeTex = THREE.ImageUtils.loadTexture("public/dirt.jpg")
        planeTex.wrapS = planeTex.wrapT = THREE.RepeatWrapping
        planeTex.repeat.set( 10, 10 )
  
        @material = new THREE.MeshLambertMaterial(map: planeTex, shading: THREE.SmoothShading, specular: 0x0, ambient: 0xeeeeee, diffuse: 0x0, color: 0x555555, shininess: 32)
        @mesh = new THREE.Mesh(@geometry, @material)
        @add(@mesh)
  
      img.src = 'public/map.jpg'
  
    getHeight: (x, z) ->
      return 0 unless @heights
  
      x += @numCols * @cellWidth * 0.5
      z += @numRows * @cellHeight * 0.5
  
      gridX = x / @cellWidth
      gridZ = z / @cellHeight
  
      col0 = Math.floor(gridX)
      row0 = Math.floor(gridZ)
      col1 = col0 + 1
      row1 = row0 + 1
  
  
      # make sure that the cell coordinates don't fall
      # outside the height field.
      if col1 > @numCols
        col1 = 0
      if row1 > @numRows
        row1 = 0
  
      # get the four corner heights of the cell from the height field
      h00 = @heights[col0 + row0 * (@numCols + 1)]
      h01 = @heights[col1 + row0 * (@numCols + 1)]
      h11 = @heights[col1 + row1 * (@numCols + 1)]
      h10 = @heights[col0 + row1 * (@numCols + 1)]
  
      # calculate the position of the camera relative to the cell.
      # note, that 0 <= tx, ty <= 1.
      tx = gridX - col0
      ty = gridZ - row0
  
      # the next step is to perform a bilinear interpolation
      # to compute the height of the terrain directly below
      # the object.
      txty = tx * ty
  
      height = h00 * (1 - ty - tx + txty) + h01 * (tx - txty) + h11 * txty + h10 * (ty - txty)
      height
  
  
    getHeightData: (img) ->
      canvas = document.createElement('canvas')
      canvas.width = img.width
      canvas.height = img.height
      context = canvas.getContext('2d')
  
      size = img.width * img.height
      data = new Float32Array(size)
  
      context.drawImage(img, 0, 0)
  
      imgd = context.getImageData(0, 0, img.width, img.height)
      pix = imgd.data
  
      j = 0
      for pic, i in pix by 4
        all = pic + pix[i + 1] + pix[i + 2]
        data[j++] = all / 30
  
      data
  */


  Milk.MoonLevel = (function(_super) {

    __extends(MoonLevel, _super);

    function MoonLevel() {
      MoonLevel.__super__.constructor.call(this, {
        bootstrap: true
      });
      this.terrain = new Milk.MoonTerrain;
      this.skybox = new Milk.Skybox("public/skybox");
    }

    MoonLevel.prototype.stage = function() {
      MoonLevel.__super__.stage.apply(this, arguments);
      this.terrain.stage();
      return this.skybox.stage();
    };

    MoonLevel.prototype.update = function() {
      var mapHeightAtCamera;
      mapHeightAtCamera = this.terrain.heightAtPosition(this.camera.position);
      return this.camera.position.y = mapHeightAtCamera + 2;
    };

    return MoonLevel;

  })(Milk.Level);

  Milk.MoonTerrain = (function(_super) {

    __extends(MoonTerrain, _super);

    function MoonTerrain() {
      var _this = this;
      MoonTerrain.__super__.constructor.apply(this, arguments);
      this.heightMap = new Milk.HeightMap("public/map.jpg");
      this.notReady();
      this.texture = THREE.ImageUtils.loadTexture("public/dirt.jpg", null, function() {
        return _this.ready();
      });
      this.texture.wrapS = this.texture.wrapT = THREE.RepeatWrapping;
      this.texture.repeat.set(10, 10);
      this.material = new THREE.MeshLambertMaterial({
        map: this.texture,
        shading: THREE.SmoothShading,
        specular: 0x0,
        ambient: 0xeeeeee,
        diffuse: 0x0,
        color: 0x555555,
        shininess: 32
      });
    }

    MoonTerrain.prototype.stage = function() {
      var geo;
      geo = this.heightMap.stage();
      this.mesh = new THREE.Mesh(geo, this.material);
      return this.scene.add(this.mesh);
    };

    MoonTerrain.prototype.heightAtPosition = function(position) {
      return this.heightMap.heightAtPosition(position);
    };

    return MoonTerrain;

  })(Milk);

  Milk.Actor = (function(_super) {

    __extends(Actor, _super);

    function Actor() {
      return Actor.__super__.constructor.apply(this, arguments);
    }

    return Actor;

  })(Milk);

  Milk.Spaceman = (function(_super) {

    __extends(Spaceman, _super);

    function Spaceman() {
      return Spaceman.__super__.constructor.apply(this, arguments);
    }

    Spaceman.prototype.render = function() {
      var sprite;
      sprite = new Milk.Sprite("public/robot.png");
      return this.scene.add(sprite);
    };

    return Spaceman;

  })(Milk);

  /*
  class Player extends THREE.Object3D
  
  	ITEM_OPTIONS =
  		dino: 'mask'
  		helmet: 'mask'
  		hat: 'hat'
  		milk: 'hand'
  		cookies: 'hand'
  
  	ITEM_OFFSETS =
  		mask:
  			x: 0
  			y: 0.6
  		hand:
  			x: 0.45
  			y: 0
  		hat:
  			x: 0
  			y: 0.9
  
  	followDistance: 8
  
  	constructor: (id, position, startingItems = []) ->
  		super()
  		@playerId = id
  		@position = position
  
  		@velocity = 0
  		@yVelocity = 0
  		@speed = 0.05
  		@maxSpeed = 0.2
  
  		@angularVelocity = 0
  		@turnSpeed = 0.01
  		@maxTurnSpeed = 0.02
  		@useQuaternion = true
  
  		@jumping = false
  		@scaleFactor = 0.0001
  
  		@items = {}
  
  
  		@boundingBox = {max: new THREE.Vector3(1, 0.8, 1)}
  
  		@voicePitch = Math.random()*100
  
  		for item in startingItems
  			@equipItem(item)
  
  	direction: ->
  		c_orient_axis = new THREE.Vector3();
  		@quaternion.multiplyVector3(new THREE.Vector3(0,0,1), c_orient_axis)
  		c_orient_axis
  
  	forward: (direction) ->
  		@velocity += @speed * direction
  		if @velocity > @maxSpeed
  			@velocity = @maxSpeed
  		else if @velocity < -@maxSpeed
  			@velocity = -@maxSpeed
  
  	jump: (direction) ->
  		if !@jumping
  			@yVelocity = @speed
  			@jumping = true
  
  	turn: (direction) ->
  		@angularVelocity += @turnSpeed * direction
  		if @angularVelocity > @maxTurnSpeed
  			@angularVelocity = @maxTurnSpeed
  		else if @angularVelocity < -@maxTurnSpeed
  			@angularVelocity = - @maxTurnSpeed
  
  	equipItem: (item) ->
  		unless @items[item]
  			itemSprite = new Sprite("#{item}.png")
  			slot = ITEM_OPTIONS[item] || "hand"
  			offset = ITEM_OFFSETS[slot]
  			itemSprite.position.set(offset.x, offset.y, 0.001)
  			@add(itemSprite)
  			@items[item] = itemSprite
  
  	unequipItem: (item) ->
  		if @items[item]
  			@remove @items[item]
  			@items[item] = null
  			delete @items[item]
  
  	update: (timestep) ->
  		rotation = new THREE.Quaternion()
  		rotation.setFromAxisAngle(new THREE.Vector3(0,1,0), @angularVelocity)
  		@quaternion.multiplySelf(rotation)
  		@angularVelocity *= 0.9
  		@velocity *= 0.8
  		@position.subSelf(@direction().multiplyScalar(@velocity))
  		@position.y += @yVelocity
  		@yVelocity -= 0.0005
  
  	afterUpdate: ->
  		@messageText?.positionOver this
  
  	displayMessage: (message) ->
  		@clearMessage() if @textMesh
  		speak.play message, pitch: @voicePitch, @clearMessage
  
  		@messageText = new TextObject message
  		game.add @messageText
  
  	clearMessage: =>
  		game.remove @messageText
  		@messageText = null
  */


  Milk.Skybox = (function(_super) {

    __extends(Skybox, _super);

    function Skybox(filepath) {
      var shader, texture, urls,
        _this = this;
      Skybox.__super__.constructor.apply(this, arguments);
      urls = ["" + filepath + "/posx.png", "" + filepath + "/negx.png", "" + filepath + "/posy.png", "" + filepath + "/negy.png", "" + filepath + "/posz.png", "" + filepath + "/negz.png"];
      this.notReady();
      texture = THREE.ImageUtils.loadTextureCube(urls, null, function() {
        if (texture.image.loadCount === 6) {
          return _this.ready();
        }
      });
      shader = THREE.ShaderUtils.lib.cube;
      shader.uniforms.tCube.texture = texture;
      this.material = new THREE.ShaderMaterial({
        uniforms: shader.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        depthWrite: false
      });
    }

    Skybox.prototype.width = 10000;

    Skybox.prototype.height = 10000;

    Skybox.prototype.depth = 10000;

    Skybox.prototype.stage = function() {
      var geo;
      geo = new THREE.CubeGeometry(this.width, this.height, this.depth, 1, 1, 1, null, true);
      this.mesh = new THREE.Mesh(geo, this.material);
      this.mesh.flipSided = true;
      return this.scene.add(this.mesh);
    };

    return Skybox;

  })(Milk);

  Milk.Sprite = (function(_super) {
    var SCALE_FACTOR;

    __extends(Sprite, _super);

    SCALE_FACTOR = 0.0001;

    function Sprite(filename) {
      var _this = this;
      this.filename = filename;
      Sprite.__super__.constructor.apply(this, arguments);
      this.notReady();
      this.texture = THREE.ImageUtils.loadTexture(this.filename, null, function() {
        _this.mesh = new THREE.Sprite({
          map: texture,
          size: SCALE_FACTOR,
          useScreenCoordinates: false,
          color: 0xffffff
        });
        _this.mesh.scale.x = texture.image.width * SCALE_FACTOR;
        _this.mesh.scale.y = texture.image.height * SCALE_FACTOR;
        return _this.ready();
      });
    }

    Sprite.prototype.render = function() {
      return this.scene.add(this.mesh);
    };

    return Sprite;

  })(Milk);

  Milk.Text = (function(_super) {
    var DEFAULT_OPTIONS;

    __extends(Text, _super);

    DEFAULT_OPTIONS = {
      size: 42,
      height: 64,
      curveSegments: 4,
      font: "helvetiker",
      weight: "normal",
      style: "normal",
      bevelEnabled: true,
      bevelThickness: 1,
      bevelSize: 1,
      bend: true,
      material: 0,
      extrudeMaterial: 1
    };

    function Text(message, options) {
      if (message == null) {
        message = '';
      }
      if (options == null) {
        options = {};
      }
      this.message = message;
      this.options = Milk.mixin({}, DEFAULT_OPTIONS, options);
      this.faceMaterial = new THREE.MeshFaceMaterial;
      this.frontMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        shading: THREE.FlatShading
      });
      this.sideMaterial = new THREE.MeshBasicMaterial({
        color: 0xbbbbbb,
        shading: THREE.SmoothShading
      });
      this.scale = 0.015;
    }

    Text.prototype.render = function() {
      var geo, mesh;
      geo = new THREE.TextGeometry(this.message, this.options);
      geo.materials = [this.frontMaterial, this.sideMaterial];
      geo.computeBoundingBox();
      geo.computeVertexNormals();
      this.midX = geo.boundingBox.max.x * this.scale / 2;
      mesh = new THREE.Mesh(geo, this.faceMaterial);
      mesh.scale = new THREE.Vector3(this.scale, this.scale, this.scale);
      return this.exportObject(mesh);
    };

    Text.prototype.update = function() {};

    Text.prototype.positionOver = function(object) {
      this.position.x = object.position.x;
      this.position.y = object.position.y + object.boundingBox.max.y + 0.5;
      this.position.z = object.position.z;
      this.lookAt(game.camera.position);
      return this.translateX(-this.width);
    };

    return Text;

  })(Milk);

  Milk.OverheadText = (function() {

    function OverheadText() {}

    return OverheadText;

  })();

  /*
  
  class window.Vehicle extends Player
  	enterTextShown: false
  	hasEntered: false
  	followDistance: 12
  
  	canEnter: ->
  		(!@hasEntered) and game.player.position.distanceToSquared(@position) < 75
  
  	enter: (player) ->
  		if not @backgroundAudio
  			@backgroundAudio = audio = document.createElement 'audio'
  			source = document.createElement 'source'
  			source.src = '/public/doctorwho.mp3'
  			audio.appendChild source
  			source = document.createElement 'source'
  			source.src = '/public/doctorwho.ogg'
  			audio.appendChild source
  			audio.autoplay = true
  			document.body.appendChild audio
  		else
  			@backgroundAudio.play()
  
  		game.remove @enterText
  		@hasEntered = true
  
  		player.parent.remove player
  		player.position.x = player.position.y = player.position.z = 0
  		@add player
  
  		return this
  
  	exit: (player) ->
  		@hasEntered = false
  		@backgroundAudio.pause()
  
  		@remove player
  		player.position.x = @position.x + 5
  		player.position.y = @position.y
  		player.position.z = @position.z + 5
  		game.add player
  
  		console.log @position.y
  
  	jump: ->
  		if not @wooshAudio
  			@wooshAudio = audio = document.createElement 'audio'
  			source = document.createElement 'source'
  			source.src = '/public/tardis.mp3'
  			audio.appendChild source
  			document.body.appendChild audio
  
  		super
  
  	update: (delta) ->
  		if @hasEntered
  			@wooshAudio?[if @jumping then 'play' else 'pause']()
  			super
  
  		else if @canEnter()
  			if @enterTextShown
  				@enterText.positionOver this
  			else
  				@enterTextShown = true
  				game.add @enterText
  		else
  			if @enterTextShown
  				@enterTextShown = false
  				game.remove @enterText
  
  class Vehicle.Tardis extends Vehicle
  	constructor: ->
  		super
  
  		geometry = new THREE.CubeGeometry(3, 5, 3)
  		material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("/public/tardisFront.jpg")})
  		mesh = new THREE.Mesh(geometry, material)
  		@add mesh
  
  		geometry.computeBoundingBox()
  		@boundingBox = geometry.boundingBox
  
  		@enterText = new TextObject 'press e to enter the tardis'
  */


}).call(this);
